

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_333 = Integer(333); _sage_const_2048 = Integer(2048); _sage_const_5 = Integer(5); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1026 = Integer(1026); _sage_const_0p3 = RealNumber('0.3'); _sage_const_0p005 = RealNumber('0.005')
from Crypto.PublicKey import RSA
from Crypto.Util.number import long_to_bytes, bytes_to_long
from time import time

flag = b"A coppersmith, also known as a brazier, is a person who makes artifacts from copper and brass. Brass is an alloy of copper and zinc. LNC24{a_r3al1y_l0Ng_rsa_keY_rec0verY_cH41n_4nd_a_r3aLLy_l0NG_fl4G} Some coppersmiths can sometimes recover RSA keys"
m = bytes_to_long(flag)
r = _sage_const_3 **_sage_const_333 
# Generate challenge params
while True:
    rsa = RSA.generate(_sage_const_2048 )
    n, p, q = rsa.n, rsa.p, rsa.q
    e = _sage_const_5 
    if gcd(e, (p-_sage_const_1 )*(q-_sage_const_1 )) == _sage_const_1 :
        break
c = pow(m, e, n)
d = pow(e, -_sage_const_1 , (p-_sage_const_1 )*(q-_sage_const_1 ))
dlo = d % r

# Solve script
start = time()
found = False
for k in range(_sage_const_1 ,e):
    print(f"Testing for k = {k}")
    kstart = time()
    if gcd(k, r) > _sage_const_1 :
        print("Cannot find solution.")
        continue
    # let s = p+q, get low bits of s
    # e*d0 == 1 + k(N - p - q + 1) mod 2**NB
    slo = -((e*dlo - _sage_const_1 ) * inverse_mod(k, r) - n - _sage_const_1  ) % r

    # F.<x> = PolynomialRing(Zmod(2**NB))
    # f = x**2 - slo * x + n
    # assert(f(p % 2**NB) == 0) # this also works for q % r
    # print(f"Quadratic: x**2 - {slo}*x + {n} == 0 % 2**{NB}")
    # solve quadratic for low bits of p or q
    a = var('a')    
    roots = [int(i[_sage_const_0 ]) for i in solve_mod([a**_sage_const_2  - slo*a + n == _sage_const_0 ], r)]
    print(f"Found {len(roots)} potential solutions")

    # plo = p % r
    # qlo = q % r
    # print(f'plo {plo in roots}')
    # print(f'qlo {qlo in roots}')
    # in this case it is possible that LSB of p is among them. Apply coppersmith / small_roots() to solve for p or q
    F = PolynomialRing(Zmod(n), names=('x',)); (x,) = F._first_ngens(1)
    for i, plo in enumerate(roots):
        print(f'{i+_sage_const_1 }/{len(roots)}',end='\r')
        f = (r * x + plo).monic()
        smroots = f.small_roots(X=_sage_const_2 **(_sage_const_1026 -r.bit_length()), beta=_sage_const_0p3 , epsilon=_sage_const_0p005 )
        if len(smroots) == _sage_const_0 :
            continue
        found_p = gcd(int(f(smroots[_sage_const_0 ])), n)
        print(f"Found prime = {found_p}")
        found = True
        break
    print(f"Round {k} took {time() - kstart} seconds.") 
    if found:
        break

print(f"Total time elapsed: {time() - start} seconds.")
# recover flag
if not found:
    exit()

found_q = n // found_p
assert found_p * found_q == n
found_d = pow(e, -_sage_const_1 , (found_p - _sage_const_1 )*(found_q - _sage_const_1 ))
m = pow(c, found_d, n)
print(long_to_bytes(m))

